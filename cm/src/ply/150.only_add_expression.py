# پایانه‌ها
tokens = ('NUMBER','PLUS',)
# Tokens
# علامت جمع
# نشانه‌های تحلیل‌گر لغوی با 
# t_
# آغاز می‌شوند
t_PLUS    = r'\+'
# برای عدد در تحلیل‌گر لغوی نیاز است تابع نوشته شود و مانند جمع نیست که یک عبارت منظم کافی باشد
# تابع‌های تحلیل‌گر لغوی با 
#  t_
# آغاز می‌شوند
def t_NUMBER(t):
  r'\d+'
  t.value = int(t.value)
  return t
# پایانه‌هایی که می‌خواهیم نادیده گرفته شوند
# Ignored characters
t_ignore = " \t"
# در صورت پیش آمدن خطا در تحلیل‌گر لغوی این تابع فراخوانی می‌شود
def t_error(t):
  print("Illegal character '%s'" % t.value[0])
  t.lexer.skip(1)
# ساخت تحلیل‌گر لغوی بر پایه‌ی اطلاعات بالا
# Build the lexer
import ply.lex as lex
lex.lex()
# آغاز بخش تحلیل‌گر نحوی و معنایی و همزمان اجرا کننده
# تابع‌های این بخش با
# p_
# آغاز می‌شود و در ادامه نام تابع که گویایی کارکرد آن باشد را می‌نویسیم
# آرگومان تابع همان بخش‌های ورودی را که این کاهش با آنها روبرو است دربردارد
# در نخستین خط این تابع‌ها باید دستور معادل این تابع به شکل نوشته شده گذاشته شود
def p_e_e_a(p):
  'E : E PLUS NUMBER'
  p[0] = p[1]+p[3]
  # عمل معنایی در بالا تعریف شده است و چون فقط یک مقدار نیاز است پس در خود همان p می‌توان مقدارها را گذاشت
  print('کاهش با قانون E → E + a  ',p[0])
def p_e_a(p):
  'E : NUMBER'
  p[0]=p[1]
  print('کاهش با قانون E → a  ',p[1])
def p_error(p):
  print("Syntax error at '%s'" % p.value)
# ساخت تحلیل‌گر نحوی و معنایی و اجرا کننده
import ply.yacc as yacc; yacc.yacc()
# گرفتن ورودی و اجرای آن
while True:
  s = input('calc > ')
  if s.strip()=='':break # با یک Enter که ورودی خالی باشد برنامه پایان یابد
  yacc.parse(s)
